#pragma kernel GeneratePoints

// Define a struct that mirrors the layout of Unity's RaycastHit data
// when passed to a ComputeBuffer. We only care about these fields.
struct UnityRaycastHit {
    float3 p;
    float3 normal;
    float distance;
    uint colliderInstanceID; // Use this to check for a valid hit (is 0 on miss)
};

// This must match the PointData struct in C#
struct PointData {
    float3 position;
    float3 normal;
    float startTime;
};

// Input and Output Buffers
StructuredBuffer<UnityRaycastHit> _RaycastHitsBuffer;
AppendStructuredBuffer<PointData> _ProcessedPointsBuffer;

// Uniforms passed from C#
float _PropagationSpeed;
float _Time;
int _RayCount;

[numthreads(64,1,1)]
void GeneratePoints (uint3 id : SV_DispatchThreadID)
{
    // Bounds check to avoid processing more threads than we have rays
    if (id.x >= _RayCount)
    {
        return;
    }

    // Step 6: GPU Point Generation
    // Read the raw hit data for this thread
    UnityRaycastHit hit = _RaycastHitsBuffer[id.x];

    // Filter out non-hits (a colliderInstanceID of 0 means no collider was hit)
    if (hit.colliderInstanceID > 0)
    {
        PointData p;
        p.position = hit.p;
        p.normal = hit.normal;
        p.startTime = _Time + (hit.distance / _PropagationSpeed);

        _ProcessedPointsBuffer.Append(p);
    }
}